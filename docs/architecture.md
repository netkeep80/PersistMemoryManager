# Архитектура PersistMemoryManager

## Обзор

`PersistMemoryManager` — single-header C++17 библиотека для управления персистентной кучей памяти. Все метаданные хранятся внутри управляемой области, что позволяет сохранять и восстанавливать образ памяти из файла или shared memory.

---

## Слои архитектуры

```
┌─────────────────────────────────────────┐
│   PersistMemoryManager (публичный API)  │
│   allocate / deallocate / reallocate    │
│   validate / dump_stats / get_stats     │
├─────────────────────────────────────────┤
│   Слой поиска и разбиения блоков        │
│   (first-fit, splitting, find_by_ptr)   │
├─────────────────────────────────────────┤
│   Слой работы с raw-памятью             │
│   (offsets, alignment, BlockHeader)     │
└─────────────────────────────────────────┘
```

---

## Структура управляемой области памяти

```
[ManagerHeader (64 байт)]
[BlockHeader_0][user_data_0.....][padding]
[BlockHeader_1][user_data_1...............][padding]
...
[BlockHeader_N][свободное пространство....]
```

### ManagerHeader

Расположен в начале буфера (offset 0). Содержит:

| Поле | Тип | Описание |
|------|-----|----------|
| `magic` | `uint64_t` | Магическое число `"PMM_V010"` для валидации |
| `total_size` | `size_t` | Полный размер управляемой области |
| `used_size` | `size_t` | Занятый объём (метаданные + данные) |
| `block_count` | `size_t` | Общее количество блоков |
| `free_count` | `size_t` | Количество свободных блоков |
| `alloc_count` | `size_t` | Количество занятых блоков |
| `first_block_offset` | `ptrdiff_t` | Смещение первого блока |

### BlockHeader

Расположен перед каждым блоком данных:

| Поле | Тип | Описание |
|------|-----|----------|
| `magic` | `uint64_t` | Магическое число `"BLOCKHDR"` |
| `prev_offset` | `ptrdiff_t` | Смещение предыдущего блока (-1 = нет) |
| `next_offset` | `ptrdiff_t` | Смещение следующего блока (-1 = нет) |
| `total_size` | `size_t` | Полный размер блока включая заголовок |
| `user_size` | `size_t` | Размер пользовательских данных |
| `alignment` | `size_t` | Выравнивание пользовательских данных |
| `used` | `bool` | Флаг занятости |

---

## Алгоритмы

### Выделение памяти (allocate)

```
1. Проверить user_size > 0 и корректность alignment
2. Вычислить required_block_size = sizeof(BlockHeader) + (alignment-1) + user_size
3. Линейный обход связного списка блоков (first-fit):
   - Найти первый свободный блок с total_size >= required_block_size
4. Если блок найден:
   a. Если блок значительно больше (можно разделить):
      - Создать новый свободный блок из остатка
      - Вставить в связный список
   b. Пометить блок как used = true
   c. Обновить счётчики в ManagerHeader
   d. Вернуть выровненный указатель на данные
5. Если не найден: вернуть nullptr
```

### Освобождение памяти (deallocate)

```
1. Если ptr == nullptr: нет операции
2. Найти BlockHeader через линейный обход (find_block_by_ptr)
3. Если блок найден и used == true:
   - Установить used = false
   - Обнулить user_size
   - Обновить счётчики в ManagerHeader
```

### Разбиение блоков (splitting)

При выделении, если найденный свободный блок значительно больше запрошенного,
он разделяется на два:

```
[BlockHeader (used)][user_data][BlockHeader (free)][остаток...]
```

Минимальный размер нового свободного блока: `sizeof(BlockHeader) + kMinBlockSize (32 байта)`.

---

## Персистентность

Все ссылки между блоками хранятся как **смещения** (`ptrdiff_t`) от начала управляемой области, а не как абсолютные указатели. Это позволяет:

1. Сохранить образ памяти в файл (`fwrite` всей области).
2. Загрузить его по другому базовому адресу (`mmap` или `malloc`).
3. Использовать в shared memory сегментах.

При загрузке (`load()`) библиотека проверяет магическое число и размер области.

---

## Выравнивание

```
[BlockHeader][0..N байт padding][user_data выровнен на alignment]
```

Паддинг вычисляется автоматически. `user_ptr()` возвращает первый байт после
`BlockHeader`, выровненный на `block->alignment`.

---

## Ограничения Фазы 1

- Нет слияния (coalescing) соседних свободных блоков — будет в Фазе 2.
- Нет сохранения/загрузки из файла — будет в Фазе 3.
- Алгоритм поиска: first-fit (линейный) — оптимизация в Фазе 5.
- Нет потокобезопасности.

---

## Диаграмма связного списка блоков

```
base_ptr
│
├── ManagerHeader
│     first_block_offset ──────┐
│                               │
├── BlockHeader_0 ◄─────────────┘
│     prev_offset = -1
│     next_offset ──────────────┐
│     used = false              │
│     [free space]              │
│                               │
├── BlockHeader_1 ◄─────────────┘
│     prev_offset ──────────────┐ (back to BlockHeader_0)
│     next_offset = -1          │
│     used = true               │
│     [user data...]            │
│                               │
└── (end of managed area)
```
