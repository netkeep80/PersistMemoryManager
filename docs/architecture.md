# Архитектура PersistMemoryManager

## Обзор

`PersistMemoryManager` — single-header C++17 библиотека для управления персистентной кучей памяти. Все метаданные хранятся внутри управляемой области, что позволяет сохранять и восстанавливать образ памяти из файла или shared memory. Взаимодействие с данными осуществляется через персистные типизированные указатели `pptr<T>`.

---

## Слои архитектуры

```
┌─────────────────────────────────────────────────────┐
│   PersistMemoryManager (публичный API)              │
│   allocate_typed / deallocate_typed (pptr<T>)       │
│   validate / dump_stats / get_stats / get_info      │
├─────────────────────────────────────────────────────┤
│   Слой поиска и разбиения блоков                    │
│   (first-fit по free list, splitting, coalescing)   │
├─────────────────────────────────────────────────────┤
│   Слой работы с raw-памятью                         │
│   (offsets, alignment, BlockHeader)                 │
└─────────────────────────────────────────────────────┘
```

---

## Структура управляемой области памяти

```
[ManagerHeader]
[BlockHeader_0][user_data_0.....][padding]
[BlockHeader_1][user_data_1...............][padding]
...
[BlockHeader_N][свободное пространство....]
```

### ManagerHeader

Расположен в начале буфера (offset 0). Содержит:

| Поле | Тип | Описание |
|------|-----|----------|
| `magic` | `uint64_t` | Магическое число `"PMM_V010"` для валидации |
| `total_size` | `size_t` | Полный размер управляемой области |
| `used_size` | `size_t` | Занятый объём (метаданные + данные) |
| `block_count` | `size_t` | Общее количество блоков |
| `free_count` | `size_t` | Количество свободных блоков |
| `alloc_count` | `size_t` | Количество занятых блоков |
| `first_block_offset` | `ptrdiff_t` | Смещение первого блока в общем списке |
| `first_free_offset` | `ptrdiff_t` | Смещение первого блока в списке свободных |
| `owns_memory` | `bool` | true — буфер принадлежит нам, `destroy()` освободит его |
| `prev_total_size` | `size_t` | Размер предыдущего буфера (0 если expand() не вызывался) |
| `prev_base` | `void*` | Предыдущий буфер после расширения (для трансляции указателей) |
| `prev_owns` | `bool` | true — предыдущий буфер принадлежит нам |

### BlockHeader

Расположен перед каждым блоком данных:

| Поле | Тип | Описание |
|------|-----|----------|
| `magic` | `uint64_t` | Магическое число `"BLOCKHDR"` |
| `prev_offset` | `ptrdiff_t` | Смещение предыдущего блока в общем списке (-1 = нет) |
| `next_offset` | `ptrdiff_t` | Смещение следующего блока в общем списке (-1 = нет) |
| `total_size` | `size_t` | Полный размер блока включая заголовок |
| `user_size` | `size_t` | Размер пользовательских данных |
| `alignment` | `size_t` | Выравнивание пользовательских данных |
| `used` | `bool` | Флаг занятости |
| `free_prev_offset` | `ptrdiff_t` | Смещение предыдущего блока в списке свободных (-1 = нет, только если used == false) |
| `free_next_offset` | `ptrdiff_t` | Смещение следующего блока в списке свободных (-1 = нет, только если used == false) |

---

## Алгоритмы

### Выделение памяти (allocate_typed)

```
1. Вычислить required_block_size = sizeof(BlockHeader) + (alignment-1) + user_size
2. Обход списка свободных блоков (first-fit, O(f)):
   - Найти первый свободный блок с total_size >= required_block_size
3. Если блок найден:
   a. Удалить из списка свободных
   b. Если блок значительно больше (можно разделить):
      - Создать новый свободный блок из остатка
      - Вставить в оба списка (общий и свободных)
   c. Пометить блок как used = true
   d. Обновить счётчики в ManagerHeader
   e. Вернуть выровненный указатель на данные (как смещение в pptr<T>)
4. Если не найден: автоматически расширить память на 25% и повторить
```

### Освобождение памяти (deallocate_typed)

```
1. Если pptr нулевой: нет операции
2. Найти BlockHeader через header_from_ptr (O(1) для типичного случая)
3. Если блок найден и used == true:
   - Установить used = false
   - Обнулить user_size
   - Обновить счётчики в ManagerHeader
   - Добавить в список свободных
   - Выполнить слияние с соседними свободными блоками (coalescing)
```

### Слияние свободных блоков (coalescing)

При освобождении блока проверяются оба соседних блока (prev и next). Если они свободны,
они сливаются в один:

```
[BlockHeader (free)][space][BlockHeader (free)] → [BlockHeader (free)][larger space]
```

### Разбиение блоков (splitting)

При выделении, если найденный свободный блок значительно больше запрошенного,
он разделяется на два:

```
[BlockHeader (used)][user_data][BlockHeader (free)][остаток...]
```

Минимальный размер нового свободного блока: `sizeof(BlockHeader) + kMinBlockSize (32 байта)`.

### Автоматическое расширение памяти (expand)

При нехватке памяти:

```
1. Выделить новый буфер размером old_size * 5/4 (не менее old_size + needed)
2. Скопировать содержимое старого буфера в новый
3. Расширить или добавить свободный блок в конце нового буфера
4. Обновить синглтон (s_instance → новый буфер)
5. Сохранить старый буфер в prev_base для трансляции указателей
6. Освободить старый буфер при destroy()
```

---

## Персистентность

Все ссылки между блоками хранятся как **смещения** (`ptrdiff_t`) от начала управляемой области, а не как абсолютные указатели. Это позволяет:

1. Сохранить образ памяти в файл (`fwrite` всей области).
2. Загрузить его по другому базовому адресу (`mmap` или `malloc`).
3. Использовать в shared memory сегментах.

При загрузке (`load()`) библиотека проверяет магическое число и размер области, затем перестраивает список свободных блоков (`rebuild_free_list`).

`pptr<T>` хранит смещение (`std::ptrdiff_t`), что делает его персистным: после загрузки образа по другому адресу то же смещение указывает на те же данные.

---

## Выравнивание

```
[BlockHeader][0..N байт padding][user_data выровнен на alignment]
```

Паддинг вычисляется автоматически. `user_ptr()` возвращает первый байт после
`BlockHeader`, выровненный на `block->alignment`.

---

## Потокобезопасность

Все публичные методы защищены `std::shared_mutex`:
- методы чтения — `shared_lock` (параллельное выполнение)
- методы записи — `unique_lock` (эксклюзивный доступ)

---

## Диаграмма структур данных

```
base_ptr
│
├── ManagerHeader
│     first_block_offset ──────┐
│     first_free_offset  ──────┼──┐
│                               │  │
├── BlockHeader_0 ◄─────────────┘  │ (free block)
│     prev_offset = -1             │
│     next_offset ──────────────┐  │
│     free_prev_offset = -1     │  │
│     free_next_offset ─────────┼──┘ (points to next free)
│     used = false              │
│     [free space]              │
│                               │
├── BlockHeader_1 ◄─────────────┘ (used block)
│     prev_offset ──────────────► (back to BlockHeader_0)
│     next_offset = -1
│     used = true
│     [user data...]
│
└── (end of managed area)
```
