# Фаза 6: Оптимизация производительности

## Статус: ✅ Завершена

## Цель

Достичь целевых показателей производительности из ТЗ:
- allocate 100K блоков ≤ 100 мс
- deallocate 100K блоков ≤ 100 мс

---

## Решённые задачи

| Задача | Статус |
|--------|--------|
| Профилирование текущей реализации | ✅ |
| Оптимизация поиска свободных блоков (отдельный список свободных) | ✅ |
| Достичь: allocate 100K блоков ≤ 100 мс | ✅ |
| Достичь: deallocate 100K блоков ≤ 100 мс | ✅ |
| Добавить benchmarks в репозиторий | ✅ |
| Написать тесты производительности | ✅ |
| Перестройка списка свободных блоков при load() | ✅ |

---

## Профилирование

### До оптимизации (Фаза 4, first-fit линейный поиск)

```
Буфер: 32 МБ
Блоков: 100 000 × 64 байта
Время аллокации:    ~15 600 мс  (O(n²) деградация first-fit)
Время деаллокации:  ~0.83 мс
```

**Причина деградации:** При паттерне «выделить всё подряд» функция `allocate()` обходила весь связный список (занятые + свободные блоки). После N аллокаций список содержит N занятых блоков и 1 свободный в конце — каждая следующая аллокация проходит через всё больше занятых блоков. Итого: O(1) + O(2) + ... + O(N) = O(N²).

---

## Реализованная оптимизация: отдельный список свободных блоков

### Идея

Вместо поиска по всему связному списку (занятые + свободные), поддерживаем **отдельный двусвязный список только из свободных блоков**. При выделении памяти обходим только свободные блоки.

### Изменения в структурах данных

**`BlockHeader`** — добавлены поля:
```cpp
std::ptrdiff_t free_prev_offset; // Предыдущий свободный блок (-1 = нет)
std::ptrdiff_t free_next_offset; // Следующий свободный блок (-1 = нет)
                                 // Используются только при used == false
```

**`ManagerHeader`** — добавлено поле:
```cpp
std::ptrdiff_t first_free_offset; // Начало списка свободных блоков
```

### Изменения в алгоритмах

| Метод | До | После |
|-------|-----|-------|
| `allocate()` | Обход всего списка (занятые + свободные) | Обход только свободных через `first_free_offset` |
| `allocate_from_block()` | — | Удаляет блок из списка свободных; добавляет остаток в список свободных |
| `deallocate()` | Помечает блок свободным | Дополнительно вставляет блок в список свободных |
| `coalesce()` | Слияние через основной список | Управляет списком свободных при каждом слиянии |
| `load()` | — | Вызывает `rebuild_free_list()` для восстановления |

### Вспомогательные функции (добавлены в `detail`)

- `free_list_insert(base, hdr, blk)` — вставить свободный блок в начало списка свободных
- `free_list_remove(base, hdr, blk)` — удалить блок из списка свободных

### Метод `rebuild_free_list()`

Обходит основной связный список всех блоков и перестраивает список свободных. Вызывается при `load()` для восстановления из образа (backward compatibility со старыми образами).

---

## Результаты после оптимизации

```
Буфер: 32 МБ
Блоков: 100 000 × 64 байта
Время аллокации:    ~7.0 мс   [цель ≤ 100 мс: ✅]
Время деаллокации:  ~0.8 мс   [цель ≤ 100 мс: ✅]
Ускорение:          ~2 230×
```

```
Буфер: 8 МБ
1 000 000 чередующихся операций
Общее время:       ~13.7 мс   (было ~31 мс)
```

---

## Анализ сложности

| Операция | До (Фаза 4) | После (Фаза 6) |
|----------|-------------|-----------------|
| `allocate` | O(n) где n = кол-во всех блоков | O(f) где f = кол-во свободных блоков |
| `deallocate` | O(n) (find_block_by_ptr) + O(1) | O(n) (find_block_by_ptr) + O(1) |
| `coalesce` | O(1) | O(1) |
| `load` + rebuild | — | O(n) (однократно) |

При паттерне «выделить всё подряд» f = 1 (всегда один свободный блок в конце), поэтому `allocate` занимает O(1) на каждый вызов — итого O(N) вместо O(N²).

---

## Созданные файлы

### `tests/test_performance.cpp` — 8 тестов

| Тест | Описание |
|------|----------|
| `alloc 100K ≤ 100ms` | Измерение времени 100K аллокаций |
| `dealloc 100K ≤ 100ms` | Измерение времени 100K деаллокаций |
| `alloc/dealloc validate` | Корректность структур при 1K операций |
| `memory reuse` | Повторное использование освобождённой памяти |
| `free list after load` | Восстановление списка свободных при load() |
| `data integrity with free list` | Неповреждённость данных при оптимизированном управлении |
| `full coalesce after alloc/dealloc` | Полное слияние после освобождения всех блоков |
| `minimum buffer size` | Корректность при минимальном буфере |

### `examples/benchmark.cpp` — 3 бенчмарка

| Бенчмарк | Описание |
|----------|----------|
| Бенчмарк 1 | 100K блоков по 64 байта |
| Бенчмарк 2 | 100K блоков разного размера (32–256 байт) |
| Бенчмарк 3 | 10K операций reallocate |

---

## Известные ограничения

1. **Overhead на блок = 72 байта** — `sizeof(BlockHeader) = 72 байт`, что превышает цель ≤ 32 байт из ТЗ. Добавление полей `free_prev_offset` и `free_next_offset` увеличило размер заголовка с 56 до 72 байт. Дальнейшее уменьшение потребовало бы пересмотра архитектуры (например, хранение данных в самом свободном блоке).

2. **Список свободных не сортирован** — при большом количестве свободных блоков разных размеров возможна неоптимальная выдача больших блоков для маленьких запросов (fragmentation). Для типичного паттерна это не проблема.

3. **`deallocate` остаётся O(n)** — поиск блока по указателю (`find_block_by_ptr`) требует обхода всего связного списка. Это не влияет на целевые показатели при нормальном использовании.

---

## Следующая фаза

**Фаза 7: Интеграция с pjson_db**

- Изучить API pjson_db
- Разработать адаптер для использования PersistMemoryManager как аллокатора в pjson_db
- Написать демонстрационный пример интеграции
- Провести нагрузочное тестирование совместной работы
