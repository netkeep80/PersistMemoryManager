# Техническое задание на разработку библиотеки PersistMemoryManager

## 1. Общие сведения

### 1.1. Наименование проекта
**PersistMemoryManager** — single-header библиотека управления персистентной кучей памяти для C++17.

### 1.2. Назначение
Библиотека предоставляет низкоуровневый менеджер персистентной памяти (кучи) для работы с бинарными образами, сохраняющимися между запусками программы. Предназначена для использования в качестве базового слоя в проектах типа `pjson_db`, `pam_core` и других персистентных хранилищах.

### 1.3. Область применения
- Персистентные базы данных
- Memory-mapped файлы
- Shared memory сегменты
- Любые сценарии, требующие сохранения структуры кучи между запусками

---

## 2. Требования к архитектуре

### 2.1. Формат распространения
| Требование | Описание |
|------------|----------|
| **Single-header** | Вся реализация в одном `.h` файле |
| **C++17** | Минимальный стандарт C++ |
| **Без зависимостей** | Только стандартная библиотека C++ |
| **Header-only** | Без `.cpp` файлов, без линковки |

### 2.2. Слои архитектуры
```
┌─────────────────────────────────────────┐
│   PersistMemoryManager (публичный API)  │
├─────────────────────────────────────────┤
│   Слой управления свободными блоками    │
│   (free list, size classes, binning)    │
├─────────────────────────────────────────┤
│   Слой управления занятыми блоками      │
│   (allocated blocks tracking)           │
├─────────────────────────────────────────┤
│   Слой работы с raw-памятью             │
│   (offsets, pointers, alignment)        │
└─────────────────────────────────────────┘
```

### 2.3. Принципы проектирования
1. **Персистентность** — все метаданные хранятся в управляемой памяти
2. **Детерминизм** — одинаковые операции дают одинаковый результат
3. **Без исключений** — обработка ошибок через коды возврата/optional
4. **Потокобезопасность** — базовая синхронизация на уровне менеджера
5. **Минимальные накладные расходы** — overhead не более 10% на метаданные

---

## 3. Алгоритм управления памятью

### 3.1. Структура блока памяти
```cpp
struct Block {
    Block* prev;              ///< Предыдущий блок в списке (для слияния)
    Block* next;              ///< Следующий блок в списке (для слияния)
    bool   used;              ///< Флаг занятости блока
    void*  parent;            ///< Указатель на контейнер (bin) этого блока
    size_t size;              ///< Размер блока в байтах (включая заголовок)
    alignas(16) byte ptr[1];  ///< Начало пользовательских данных
};
```

### 3.2. Контейнеры блоков
```cpp
struct SizeClass {
    size_t size;              ///< Размер блоков в этом классе
    vector<Block*> blocks;    ///< Список блоков данного размера
};

struct MemoryManager {
    vector<SizeClass> free_bins;      ///< Свободные блоки (сортировано по size)
    vector<SizeClass> allocated_bins; ///< Занятые блоки (сортировано по size)
    byte*             base_ptr;       ///< Начало области памяти
    size_t            total_size;     ///< Общий размер управляемой памяти
    size_t            used_size;      ///< Текущее использование
};
```

### 3.3. Алгоритм выделения памяти
```
1. Получить запрошенный размер + выравнивание
2. Бинарный поиск в free_bins по размеру
3. Если найден точный размер:
   - Извлечь блок из free_bins
   - Добавить в allocated_bins
   - Вернуть ptr
4. Если найден больший размер:
   - Извлечь блок
   - Разделить на два блока (запрошенный + остаток)
   - Первый добавить в allocated_bins
   - Второй добавить в free_bins (поддерживая сортировку)
   - Вернуть ptr
5. Если не найден: вернуть nullptr
```

### 3.4. Алгоритм освобождения памяти
```
1. По указателю найти блок в allocated_bins
2. Пометить блок как free (used = false)
3. Проверить соседей (prev/next) на свободность
4. Если сосед свободен — объединить блоки (coalescing)
5. Добавить результат в free_bins (поддерживая сортировку)
6. Обновить метаданные (used_size)
```

### 3.5. Слияние блоков (Coalescing)
```cpp
// Псевдокод слияния
void coalesce(Block* block) {
    if (block->prev && !block->prev->used) {
        block = merge_blocks(block->prev, block);
    }
    if (block->next && !block->next->used) {
        block = merge_blocks(block, block->next);
    }
}
```

---

## 4. Публичный API

### 4.1. Основной класс
```cpp
namespace pmm {

class PersistMemoryManager {
public:
    // === Инициализация ===
    static PersistMemoryManager* create(void* memory, size_t size);
    static PersistMemoryManager* load(void* memory, size_t size);
    void destroy();
    
    // === Выделение/освобождение ===
    void* allocate(size_t size, size_t alignment = 16);
    void  deallocate(void* ptr);
    
    // === Перевыделение ===
    void* reallocate(void* ptr, size_t new_size);
    
    // === Метрики ===
    size_t total_size() const;
    size_t used_size() const;
    size_t free_size() const;
    size_t fragmentation() const;
    
    // === Диагностика ===
    bool validate() const;
    void dump_stats() const;
    
    // === Сериализация ===
    bool save(const char* filename) const;
    bool load(const char* filename);
    
private:
    // Внутренняя реализация
};

} // namespace pmm
```

### 4.2. Вспомогательные структуры
```cpp
namespace pmm {

struct MemoryStats {
    size_t total_blocks;
    size_t free_blocks;
    size_t allocated_blocks;
    size_t largest_free;
    size_t smallest_free;
    size_t total_fragmentation;
};

struct AllocationInfo {
    void*  ptr;
    size_t size;
    size_t alignment;
    bool   is_valid;
};

MemoryStats get_stats(const PersistMemoryManager* mgr);
AllocationInfo get_info(const PersistMemoryManager* mgr, void* ptr);

} // namespace pmm
```

---

## 5. Требования к реализации

### 5.1. Выравнивание
| Требование | Значение |
|------------|----------|
| Минимальное выравнивание | 8 байт |
| Выравнивание по умолчанию | 16 байт |
| Поддержка custom alignment | До 4096 байт |

### 5.2. Ограничения размеров
| Параметр | Минимум | Максимум |
|----------|---------|----------|
| Размер области памяти | 4 КБ | 2^48 байт |
| Минимальный блок | 32 байта | — |
| Максимальный блок | — | 2^47 байт |
| Количество size classes | 1 | 256 |

### 5.3. Обработка ошибок
```cpp
enum class ErrorCode {
    OK = 0,
    OUT_OF_MEMORY,
    INVALID_POINTER,
    INVALID_ALIGNMENT,
    CORRUPTED_METADATA,
    FILE_IO_ERROR
};

struct Result {
    ErrorCode code;
    const char* message;
};
```

### 5.4. Персистентность метаданных
- Все указатели хранятся как **смещения** (offsets) от base_ptr
- При загрузке образа указатели пересчитываются автоматически
- Поддержка разных базовых адресов при загрузке

---

## 6. Требования к производительности

### 6.1. Временная сложность
| Операция | Сложность | Примечание |
|----------|-----------|------------|
| allocate | O(log n) | Бинарный поиск по bins |
| deallocate | O(log n) | + слияние соседей |
| reallocate | O(log n) | + копирование данных |
| get_stats | O(1) | Кэшированные значения |
| validate | O(n) | Проверка всех блоков |

### 6.2. Целевые показатели
| Метрика | Значение |
|---------|----------|
| Overhead на блок | ≤ 32 байта |
| Фрагментация (типичная) | ≤ 15% |
| Скорость allocate (100K блоков) | ≤ 100 мс |
| Скорость deallocate (100K блоков) | ≤ 100 мс |

---

## 7. Требования к тестированию

### 7.1. Единичные тесты
- [ ] Выделение блоков разных размеров
- [ ] Освобождение в случайном порядке
- [ ] Слияние соседних свободных блоков
- [ ] Разделение больших блоков
- [ ] Выравнивание (8, 16, 32, 64, 4096)
- [ ] Переполнение (out of memory)
- [ ] Неверные указатели (invalid pointer)
- [ ] Сохранение/загрузка образа

### 7.2. Интеграционные тесты
- [ ] 100,000 аллокаций подряд
- [ ] Чередование allocate/deallocate (1M операций)
- [ ] Работа с memory-mapped файлом
- [ ] Многопоточный доступ (если поддерживается)

### 7.3. Тесты на персистентность
- [ ] Создать → сохранить → закрыть → загрузить → проверить
- [ ] Изменить базовый адрес при загрузке
- [ ] Повреждённые метаданные (должны детектироваться)

---

## 8. Требования к документации

### 8.1. Встроенная документация
- Комментарии на **русском языке** для всех публичных API
- Примеры использования для каждой основной функции
- Предусловия и постусловия для критичных функций

### 8.2. Внешняя документация
- README.md с быстрым стартом
- Примеры кода в отдельной папке `examples/`
- Диаграммы архитектуры (ASCII или .png)

### 8.3. Пример использования
```cpp
#include "persist_memory_manager.h"

int main() {
    // Выделить память под менеджер (например, 1 MB)
    void* memory = std::malloc(1024 * 1024);
    
    // Создать менеджер
    auto* mgr = pmm::PersistMemoryManager::create(memory, 1024 * 1024);
    
    // Выделить блоки
    void* block1 = mgr->allocate(256);
    void* block2 = mgr->allocate(1024, 32);  // с выравниванием 32
    
    // Освободить
    mgr->deallocate(block1);
    
    // Получить статистику
    auto stats = pmm::get_stats(mgr);
    
    // Сохранить образ
    mgr->save("memory.dat");
    
    // Очистить
    mgr->destroy();
    std::free(memory);
    
    return 0;
}
```

---

## 9. Структура репозитория

```
PersistMemoryManager/
├── include/
│   └── persist_memory_manager.h    # Single-header реализация
├── examples/
│   ├── basic_usage.cpp             # Базовое использование
│   ├── persistence_demo.cpp        # Демонстрация персистентности
│   └── stress_test.cpp             # Стресс-тест
├── tests/
│   ├── test_allocate.cpp           # Тесты выделения
│   ├── test_deallocate.cpp         # Тесты освобождения
│   ├── test_coalesce.cpp           # Тесты слияния
│   ├── test_persistence.cpp        # Тесты персистентности
│   └── CMakeLists.txt              # Сборка тестов
├── docs/
│   ├── architecture.md             # Архитектура
│   ├── api_reference.md            # API справка
│   └── performance.md              # Производительность
├── CMakeLists.txt                  # Основная сборка
├── README.md                       # Описание проекта
└── LICENSE                         # Лицензия (Unlicense/MIT)
```

---

## 10. Критерии приёмки

### 10.1. Обязательные
- [ ] Single-header файл ≤ 1500 строк
- [ ] Все тесты проходят (100% pass rate)
- [ ] Нет утечек памяти (valgrind/ASan clean)
- [ ] Документация на русском языке
- [ ] Примеры компилируются и работают

### 10.2. Желательные
- [ ] Покрытие тестами ≥ 90%
- [ ] CI/CD пайплайн (GitHub Actions)
- [ ] Benchmarks в репозитории
- [ ] Интеграция с pjson_db продемонстрирована

---

## 11. План разработки

| Фаза | Задача | Срок |
|------|--------|------|
| 1 | Базовая структура и allocate/deallocate | 1 неделя |
| 2 | Слияние блоков (coalescing) | 3 дня |
| 3 | Персистентность (save/load) | 3 дня |
| 4 | Тесты и документация | 1 неделя |
| 5 | Оптимизация производительности | 3 дня |
| 6 | Интеграция с pjson_db | 3 дня |

**Итого:** ~4 недели

---

## 12. Контакты и поддержка

- **Репозиторий:** GitHub (создаётся отдельно)
- **Лицензия:** Unlicense (общественное достояние)
- **Язык разработки:** C++17
- **Язык документации:** Русский
- **Основное использование:** pjson_db и совместимые проекты

---

*Документ версии 1.0, дата: 2026-03-01*